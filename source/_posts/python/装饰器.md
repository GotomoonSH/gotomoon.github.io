---
title: Python装饰器
date: 2019-1-21 13:20:10
tags: [Python]
categories: Python
---

# python的函数
1. 在python中函数是一等对象，是一种特殊类型的变量。可以作为参数传递给函数，也可以作为返回值返回。
python中的整数，字符串，字典都是一等对象。

2. 函数装饰器在导入模块是立即执行，被装饰的函数只在明确调用时运行。


# 什么是闭包？
通过调用含有一个内部函数加上该外部函数持有的外部局部变量的外部函数产生的一个实例函数。

```python
def outer(i):
    j = 1
    def inner():
        x = i + j
        print(x)
    return inner

test = outer(5)
test()

#输出 6
```
外部函数"outer()",内部函数"inner()",外部函数的局部变量"i,j"。
在内部函数中调用了外部函数"outer()"的局部变量"i,j"，最后返回内部函数"inner()"的引用，此为闭包。

>* 一般情况下，如果一个函数结束，函数的内部所有东西都会被释放，局部变量都会消失。闭包是一种特殊情况，如果外函数在结束时发现有自己的临时变量将会在内部函数中用到，就会把这个临时变量绑定给了内部函数，然后再结束。


# 什么是装饰器？
装饰器本质上是一个Python函数，它可以让其他函数在不需要做任何代码变动的前提下增加额外功能，装饰器的返回值也是一个函数对象。
实际上，装饰器就是一个闭包，把一个函数当作参数然后返回一个替代版函数。

假设现在有函数sayHi()
```python
def sayHi():
	print("hello,world!")
s=sayHi
s()
```
>* 输出
* "hello,world!"

在不修改“sayHi”函数的情况下在其之前再输出一句话，这种在代码运行期间动态增加功能的方式，称之为“装饰器”。 本质上，装饰器就是一个返回函数的高阶函数
```python
def sayName(func):
	def inner():
		print("I'm Pi")
		return func
	return inner()

def sayHi():
	print("hello world")

s=sayName(sayHi)
s()
```
>* 输出
* "I'm Pi
* hello world"

使用语法糖"@"简化创建s变量
```python
def sayName(func):
    def inner():
        print("I'm Yu")
        return func()
    return inner

@sayName
def sayHi():
    print('Hello, World')

sayHi()
```
在sayHi上边增加一个@sayName，其意义就是在python解释器之行到此处时，会调用装饰器函数"sayName"，并把被装饰得函数"sayHi"作为参数传入。此时的sayHi已经不是未加装饰时的函数了，而是指向sayName.inner函数地址。在接下来调用sayHi()时，其实就是调用sayName.inner。


# 有参函数装饰
```python
def sayName(func):
	def inner(name):
		print("I'm Pi")
		return func(name)
	return inner
@sayName

def sayHi(name):
	print('hello '+name)

sayHi('siri')
```

# 两个装饰器装饰函数
```python
def sayName(func):
    print('name')
    def inner():
        print("I'm Yu")
        return func()
    return inner

def sayAge(func):
    print('age')
    def inner():
        print("i'm 30")
        return  func()
    return inner

@sayName
@sayAge
def sayHi():
    print('Hello, World')

sayHi()
```
>* 输出：
* age
* name
* I'm Yu
* i'm 30
* Hello, World
首先，python解释器执行到第一个装饰器@sayName，在接下来发现装饰器下边不是一个函数而是另一个装饰器，解释器会执行第二个的装饰器@sayAge，然后把sayHi函数传入装饰器，所以首先输出了“age”，当@sayAge装饰完成，此时的sayHi函数地址指向了sayAge.inner的地址，解释器会返回去执行@sayName装饰器来装饰新的sayHi，从而输出了“name”，接着函数当前指向sayName.inner会先输出“I'm Yu”，在这里返回的func()其实就是返回的sayAge.inner，所以在下面输出i'm 30，最后输出原本sayHi的“Hello, World”

# 有参装饰器
```python
def now(time):
    def sayName(func):
        def inner(name):
            print('现在是: %s' % time)
            print("I'm Yu")
            return func(name)
        return inner
    return sayName

@now('2016/10/30')
def sayHi(name):
    print('Hello,' + name)

sayHi('siri')
```

# 装饰器的用处
装饰器本质上上一个python函数，可以使其他函数在不需要做任何代码变动的前提下增加额外功能。
使用场景：插入日志，性能测试，事务处理，缓存，权限检验等。
使用装饰器，可以抽离出大量与函数功能本身无关的雷同代码并继续重用。
概括的讲，装饰器就是位已经存在的对象添加额外的功能。

```python
def log_name(func):
	def wrapper(*arg,**kw):
		print("start %s" % func.__name__)
		return func(*arg,**kw)
	return wrapper

@log_name
def func_a(arg):
	pass

@log_name
def func_b(arg):
	pass
	
@log_name
def func_c(arg):
	pass
```

# 装饰器原理
https://www.zhihu.com/question/26930016

